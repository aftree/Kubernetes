<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learn Theme for Hugo on Hugo 主题的 Learn 文档</title>
    <link>https://k8s.lijun.in/zh/</link>
    <description>Recent content in Learn Theme for Hugo on Hugo 主题的 Learn 文档</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 09 Apr 2016 16:50:16 +0200</lastBuildDate>
    
	<atom:link href="https://k8s.lijun.in/zh/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Deployment</title>
      <link>https://k8s.lijun.in/zh/concepts/workloads-controllers/deployment/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0200</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/workloads-controllers/deployment/</guid>
      <description>apiVersion: extensions/v1beta1 # 接口版本 kind: Deployment # 接口类型 metadata: name: cango-demo # Deployment名称 namespace: cango-prd # 命名空间 labels: app: cango-demo # 标签 spec: replicas: 3 strategy: # 部署策略 rollingUpdate: # 由于replicas为3,则整个升级,pod个数在2-4个之间 maxSurge: 1 # 滚动升级时会先启动1个pod maxUnavailable: 1 # 滚动升级时允许的最大Unavailable的pod个数 template: metadata: labels: app: cango-demo # 模板名称必填 sepc: # 定义容器模板,该模板可以包含多个容器 containers: - name: cango-demo # 镜像名称 image: swr.cn-east-2.myhuaweicloud.com/cango-prd/cango-demo:0.0.1-SNAPSHOT # 镜像地址 command: [ &amp;#34;/bin/sh&amp;#34;,&amp;#34;-c&amp;#34;,&amp;#34;cat /etc/config/path/to/special-key&amp;#34; ] # 启动命令 args: # 启动参数 - &amp;#39;-storage.</description>
    </item>
    
    <item>
      <title>Service</title>
      <link>https://k8s.lijun.in/zh/concepts/serviceslb-and-networking/service/service/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0200</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/serviceslb-and-networking/service/service/</guid>
      <description>Service Kubernetes Pod 是有生命周期的，它们可以被创建，也可以被销毁，然而一旦被销毁生命就永远结束。 通过 ReplicationController 能够动态地创建和销毁 Pod。 每个 Pod 都会获取它自己的 IP 地址，即使这些 IP 地址不总是稳定可依赖的。 这会导致一个问题：在 Kubernetes 集群中，如果一组 Pod（称为 backend）为其它 Pod （称为 frontend）提供服务，那么那些 frontend 该如何发现，并连接到这组 Pod 中的哪些 backend 呢？
关于 Service
Kubernetes Service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 —— 通常称为微服务。 这一组 Pod 能够被 Service 访问到，通常是通过 Label Selector（查看下面了解，为什么可能需要没有 selector 的 Service）实现的。
举个例子，考虑一个图片处理 backend，它运行了3个副本。这些副本是可互换的 —— frontend 不需要关心它们调用了哪个 backend 副本。 然而组成这一组 backend 程序的 Pod 实际上可能会发生变化，frontend 客户端不应该也没必要知道，而且也不需要跟踪这一组 backend 的状态。 Service 定义的抽象能够解耦这种关联。
对 Kubernetes 集群中的应用，Kubernetes 提供了简单的 Endpoints API，只要 Service 中的一组 Pod 发生变更，应用程序就会被更新。 对非 Kubernetes 集群中的应用，Kubernetes 提供了基于 VIP 的网桥的方式访问 Service，再由 Service 重定向到 backend Pod。</description>
    </item>
    
    <item>
      <title>StatefulSet</title>
      <link>https://k8s.lijun.in/zh/concepts/workloads-controllers/statefulset/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0200</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/workloads-controllers/statefulset/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ReplicaSet</title>
      <link>https://k8s.lijun.in/zh/concepts/workloads-controllers/replicaset/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0200</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/workloads-controllers/replicaset/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ReplicationController</title>
      <link>https://k8s.lijun.in/zh/concepts/workloads-controllers/replicationcontroller/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0201</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/workloads-controllers/replicationcontroller/</guid>
      <description></description>
    </item>
    
    <item>
      <title>DaemonSet</title>
      <link>https://k8s.lijun.in/zh/concepts/workloads-controllers/daemonset/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0200</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/workloads-controllers/daemonset/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Job</title>
      <link>https://k8s.lijun.in/zh/concepts/workloads-controllers/job/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0200</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/workloads-controllers/job/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CronJob</title>
      <link>https://k8s.lijun.in/zh/concepts/workloads-controllers/cronjob/</link>
      <pubDate>Sat, 09 Apr 2016 16:50:16 +0200</pubDate>
      
      <guid>https://k8s.lijun.in/zh/concepts/workloads-controllers/cronjob/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Credits</title>
      <link>https://k8s.lijun.in/zh/credits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://k8s.lijun.in/zh/credits/</guid>
      <description>Contributors Thanks to them for making Open Source Software a better place !
And a special thanks to @vjeantet for his work on docdock, a fork of hugo-theme-learn. v2.0.0 of this theme is inspired by his work.
Packages and libraries  mermaid - generation of diagram and flowchart from text in a similar manner as markdown font awesome - the iconic font and CSS framework jQuery - The Write Less, Do More, JavaScript Library lunr - Lunr enables you to provide a great search experience without the need for external, server-side, search services&amp;hellip; horsey - Progressive and customizable autocomplete component clipboard.</description>
    </item>
    
    <item>
      <title>Showcase</title>
      <link>https://k8s.lijun.in/zh/showcase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://k8s.lijun.in/zh/showcase/</guid>
      <description>TAT by OVH Tshark.dev by Ross Jacobs inteliver by Amir Lavasani </description>
    </item>
    
    <item>
      <title>Site param</title>
      <link>https://k8s.lijun.in/zh/shortcodes/siteparam/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://k8s.lijun.in/zh/shortcodes/siteparam/</guid>
      <description>Les shortcode siteparam est utilisé pour vous aider à afficher des valeurs provenant des paramètres globaux du site.
Par exemple, dans ce site, le paramètre editURL est utilisé dans le fichier config.toml
[params] editURL = &amp;#34;https://github.com/matcornic/hugo-theme-learn/edit/master/exampleSite/content/&amp;#34; Utilisez le shortcode siteparam pour affichier sa valeur.
Valeur de `editURL` : {{% siteparam &amp;quot;editURL&amp;quot; %}} s&amp;rsquo;affiche comme
Valeur de editURL : https://github.com/matcornic/hugo-theme-learn/edit/master/exampleSite/content/</description>
    </item>
    
  </channel>
</rss>